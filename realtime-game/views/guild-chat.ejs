<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title><%= guild %> Guild Chat</title>
  <link rel="stylesheet" href="/styles.css" />
  <link rel="stylesheet" href="/css/navbar.css">
  <script src="/socket.io/socket.io.js"></script>
</head>
<body class="<%= guild %>">

  <%- include('partials/navbar', { user, guild }) %>

  <main>
    <h2><%= guild %> Guild Chat</h2>
    <div id="messages" style="border: 1px solid #ccc; padding: 1rem; height: 300px; overflow-y: scroll; margin-bottom: 1rem;"></div>
    <input id="msgInput" placeholder="Type your message..." />
    <button id="sendBtn">Send</button>
    <p id="warning" style="color:red; display:none; font-weight:bold; margin-top:0.5rem;">
      ⚠️ Please avoid using inappropriate language.
    </p>
  </main>

  <script>
  const socket = io();
  const guild = "<%= guild %>";
  const me = "<%= user %>";                       // ← know who I am
  const warningEl = document.getElementById("warning");
  const msgInput = document.getElementById("msgInput");
  const sendBtn = document.getElementById("sendBtn");
  const messagesEl = document.getElementById("messages");

  socket.emit("joinGuildRoom", guild);

  // ===== Receive messages (WhatsApp-like alignment) =====
  socket.on("guildMessage", (data) => {
    const url = data.avatar || "/uploads/default.png";
    const isDefault = !data.avatar || data.avatar === "/uploads/default.png";
    const isMe = (data.user === me);

    const wrapper = document.createElement("div");
    wrapper.className = "chat-message" + (isMe ? " me" : "");

    // avatar
    const avatarDiv = document.createElement("div");
    avatarDiv.className = "chat-avatar";
    avatarDiv.innerHTML = `<img src="${url}" alt="${data.user}" class="${isDefault ? 'avatar--default' : ''}">`;

    // bubble
    const textDiv = document.createElement("div");
    textDiv.className = "chat-text";

    const meta = document.createElement("div");
    meta.className = "chat-meta";
    const name = document.createElement("span");
    name.className = "name";
    name.textContent = data.user;
    const time = document.createElement("span");
    time.className = "time";
    time.textContent = new Date().toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
    meta.appendChild(name);
    meta.appendChild(time);

    const body = document.createElement("div");
    body.textContent = data.message;

    textDiv.appendChild(meta);
    textDiv.appendChild(body);

    if (isMe) {
      wrapper.appendChild(textDiv);
      wrapper.appendChild(avatarDiv);
    } else {
      wrapper.appendChild(avatarDiv);
      wrapper.appendChild(textDiv);
    }

    messagesEl.appendChild(wrapper);
    messagesEl.scrollTop = messagesEl.scrollHeight;
  });

  // ===== Smarter profanity filter (handles 1337 & repeated letters) =====
  const BAD = [
    "fuck","shit","bitch","asshole","bastard","slut","dick","piss","cunt",
    "bollocks","wanker","prick","whore","jerk","moron","retard","damn","crap",
    "arse","twat","nigger","faggot",
    "mierda","gilipollas","cabron","cabrona","puta","puto","coño","pendejo","pendeja",
    "imbecil","estupido","estupida","maricon","culero","hijo de puta","chinga","chingar",
    "joder","carajo","malparido","zorra","tonto","idiota","baboso","bobo"
  ];

  // Normalization helpers
  const leetMap = { '0':'o','1':'i','!':'i','3':'e','4':'a','@':'a','5':'s','$':'s','7':'t','8':'b' };
  const accentsMap = {'á':'a','à':'a','ä':'a','â':'a','ã':'a','ç':'c','é':'e','è':'e','ë':'e','ê':'e',
                      'í':'i','ì':'i','ï':'i','î':'i','ñ':'n','ó':'o','ò':'o','ö':'o','ô':'o','õ':'o',
                      'ú':'u','ù':'u','ü':'u','û':'u','ý':'y','ÿ':'y'};

  function normalize(s){
    let t = s.toLowerCase();
    // replace accents
    t = t.split('').map(ch => accentsMap[ch] || ch).join('');
    // swap common leetspeak
    t = t.replace(/[0!13@45$78]/g, m => leetMap[m] || m);
    // strip non-letters/numbers and collapse spaces
    t = t.replace(/[^a-z0-9\s]/g, ' ');
    // collapse repeated letters (e.g., fuuuuuck -> fuuck -> fuck)
    t = t.replace(/([a-z0-9])\1{2,}/g, '$1$1');
    // collapse spaces
    t = t.replace(/\s+/g, ' ').trim();
    return t;
  }

  // Build regexes with loose boundaries (covers "f u c k", "fu-ck", etc.)
  const badPatterns = BAD.map(w => {
    const word = normalize(w).replace(/\s+/g, '');
    const chars = word.split('').map(ch => ch.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'));
    const fuzzy = chars.join('[\\s\\W_]*'); // allow separators between letters
    return new RegExp(`\\b${fuzzy}\\b`, 'i');
  });

  function containsBadLanguage(message){
    const t = normalize(message);
    return badPatterns.some(rx => rx.test(t));
  }

  function sendMessage(){
    const msg = msgInput.value.trim();
    if (!msg) return;

    if (containsBadLanguage(msg)) {
      warningEl.style.display = "block";
      setTimeout(() => warningEl.style.display = "none", 2800);
      return;
    }
    socket.emit("guildMessage", { guild, message: msg });
    msgInput.value = "";
  }

  // listeners
  sendBtn.addEventListener("click", sendMessage);
  msgInput.addEventListener("keypress", (e) => { if (e.key === "Enter") sendMessage(); });

  // online counter passthrough stays as-is
  socket.on("updateOnline", (count) => {
    const onlineEl = document.getElementById("onlineCount");
    if (onlineEl) onlineEl.textContent = count;
  });
</script>
</body>
</html>